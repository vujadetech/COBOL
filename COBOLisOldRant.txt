IT's Lost in Translation; Legacy Systems are a National Security Risk or: Why Phil Murphy had a rough week in New Jersey last night
A modern legacy
Software Engineering is a Difficult Subject

It's rough in NJ, but it's even worse in the Rocky Mountains because there's a lot of mainframes in COBOLorado. 

lite bulb engineer/space pen

Legacy: IT is the only field where that's an insult. 
- Some universities use legacy as part of the criteria. George W. Bush's admission to Yale was at least in part determined by the fact that his father not only graduated from Yale but was also one of their star athletes. 

Although it seems very science-y, computer science is not, in fact, science. Yet somehow, Grace Hopper has blinded me with science nevertheless [https://www.facebook.com/hank.igoe.54/posts/236723447705607].
Software engreering is a branch of engineering, or at least one should hope, given its name. 
Maybe physics is broken? [Tacoma Narrows Bridge, https://www.youtube.com/watch?v=j-zczJXSxnw] The Tacoma Narrows debacle reminds me of the looming legacy debacle. 

COBOL sucks. In the interest of full disclosure, before I begin my tirade, I must divulge that. On second thought, no, let me be more precise: COBOL is *boring*. 

COBOL is an ancient language. C language has been around since 1970. Lisp was 1958. Much of R is Fortran (1960?). And python is written in C. So the so-called modernity issue doesn't get off the ground. 

 Java is from 1990, so it's "new." 
Nevertheless, Java can be justified for the same reason as COBOL: if it ain't broke, don't fix it.
The basis for functional programming, the Curry-Howard correspondence, was discovered in 1969 based on Curry's work going back to 1934. 

Virtualization was invented by Alan Turing in the 1920s. 

The new Tesla S has square wheels because round ones are *soooo* 5000 B.C. "I saw this *caveman* pull up in a car with *round wheels*, can you believe it? What a Luddite!" 

Apply the same logic to the Medical Profession. Imagine someone saying, "Medicine is an archaic field, no one is studying it anymore. Young people dont get sick very often so they don't see the point of it. Let's shutter our medical schools. Wait, put a pin in that. Ok, here's a crazy idea: maybe we could ... *train more doctors*?" It's just crazy enough to work. 

Euclidean algorithms? Fuhgeddaboutit! 

[An image problem, https://www.computerworld.com/article/2554103/cobol--not-dead-yet.html “has been tainted with the brush of mainframes.”]
"Pope Frances is a man of the people. If you don't believe me, just ask his publicist." I kid, I love Pope Frances. COBOL didn't have a good publicist. 

What happens when little rocket man sends a bomb that takes out substantial infrastructure, including the ISP? Maybe power as well? 

"A procedural language, Cobol is not perceived to be as agile as object-oriented languages for modern programming needs such as mobile apps and the Web." But that's an apples to oranges comparison since an employment office in NJ is a different beast. An unemployment check doesn't need to be retweeted by Kim Kardashian. And by the way, COBOL has been OO since 2002. Of course they used the word "perceived," which is an important distinction. If COBOL were a celebrity, it would have a Q-rating on par with Logan Paul during his "Suicide Forest" epoch. Perception is paramount, even in the thrill-a-minute world of corporate/government business logic for accountantcy report generation by mainframes. 

The language is easy to learn. That was the whole *point*, wasn't it? I'm facepalming over here[tinyurl.com/cobolfacepalm]. Grace Hopper was no fool. How long would it take a competent Java coder to become facile with COBOL? A few weeks? Maybe a few months? There's 9 million Java coders in the US according to Oracle, 10 million according to wikipedia. Around 5 million C++ coders as well. There could be some overlap with the Java figure, but take the lower bound of those figures, throw in a few million pythonistas, and conservatively we're well into double digit millions of potential COBOL coders out there just a few months down the line. 

[plumber story at elon] "Is that shit on that toilet?" "Hell, I'll pull that out with my teeth." Say what you want, the man got things done. 

We can have a bunch of snowflakes whining about the fact that COBOL isn't cool.
[Ford quote, "don't offer a complaint, offer a remedy"]

Bad software engineering is possible in any language. 

Migrating COBOL to Java isn't a magic bullet. Is it possible 
[Java is becoming what COBOL was, https://www.javacodegeeks.com/2018/06/java-becoming-cobol.html]

"Shakespeare's sonnets are being migrated from English to Spanish." If a poem is terrible in English, rewriting it in Spanish won't help.
Translating a Shakespeare sonnet from English to Spanish, sure. Translating _Cien años de soledad_, likewise. But "migrating" it? That is to say, English is such an 

Nietschze 
Using that language will force your mind to *think differently*. 
Lisp: Mathematically beautiful; dare I say, poetic even. COBOL: Not so much. 
Klingon/spanish: 

[Knuth on flavor of the month, MIXX etc]

"I can't believe we need Cobalt [sic] programmers." But does that point out a weakness of the language, or rather a weakness in HR staffing and training? As bad as the situation was, it could have been much worse. This was just the canary in the coalmine. 

Pascal suffered a similar fate. Pascal is a better educational language than C/C++, but on your resume, no one cared about Pascal. Admittedly it suffered weaknesses for production environments. [Pascal is not my favorite, https://www.lysator.liu.se/c/bwk-on-pascal.html] They wanted to see C/C++. Much like the hype around lambda calculus today, then the hype was around OO. The difference between Pascal and COBOL is that Pascal didn't wind up being inexerobly entrenched in corporate/government operations to the extent COBOL has.  

It's not just inertia: https://www.networkworld.com/article/3148714/why-banks-love-mainframes.html.

Perhaps APIs could allow migration: https://www.networkworld.com/article/3097051/mainframes-and-the-api-economy.html.
But if so, why hasn't it happened? And would it be better than just training people in COBOL? 

"You've got 3 choices: teach COBOL, resign, or get locked up [otis the town drunk, https://www.youtube.com/watch?v=eVJfXBCddbI]. Which would you prefer?" [kim davis] Imagine Prof Dijkstra's chagrin with *not* teaching COBOL being a criminal offence. 
We could conceivably hasten societal collapse because we weren't willing to learn an easy, but uncool, programming language. 

Is there a lanuage on Earth right now, BASIC, Haskell, whatever, which can be used for a 

"Do one thing, and do it well." COBOL does precisely that, and consequently, it's a victim of its own success. (Java may be "Write once, run anywhere," but COBOL is "write once, run forever". Not literally, of course. "Forever" just means "decades after the code's author has died.") One way to assure that there is plenty of dev talent is to use a language in which it's difficult to create software that isn't breaking all the time. 
If the language being used facilitates writing brittle software, which means frequently bringing in devs to fix breaking products, they'll be getting lots of practice in using that language. (Is that the secret to Silicon Valley's success? If there's one cliche that stands out in Silicon Valley, it's "break stuff." Well that or "make the world a better place," ugh. [commencing eye roll sequence now https://www.youtube.com/watch?v=3xnZ6g14WwY])

A: "So it sounds like 'didn't see this coming' woldn't be an apt phrase to describe this situation, is that right?"
B: "Indeed. Unless by 'didn't see this coming' you mean 'had fewer than 4 decades to see this coming'

[cobol threatens global stability, https://www.techradar.com/news/an-old-programming-language-is-threatening-global-stability]
It's strange to criticize a language in this circumstance. I've never heard anyone claim, "Donald Trump's obnoxious tweets are a failure of English." Although I'm a Trump fan, admittedly his tweets are sometimes a bit much, but it isn't fair to fault the English language itself. Or maybe this was Ms. Hopper's plan all along? Perhaps she was privately a communist? Ah, genius! What's a better way to avoid a 50s-era McCarthy hearing than becoming a senior naval officer? She was a commie hiding in plain sight! Rear Admiral Grace Hopper goes rogue, sows seeds of global unrest by unleashing an awful programming language, six decades in the making! Wait, that doesn't sound right. Of course it wasn't Hopper alone that created COBOL, but a committee drawn from members of CODASYL and the DOD [Real creators of COBOL, https://www.computer.org/csdl/magazine/so/2000/02/s2030/13rRUy2YLWb]. Maybe the real reason it's called COBOL is that it was created by a CABAL. That wasn't very clever, the global search and replace of "O" with "A" is transparently obvious. But seriously folks ...

If the COBOL haters are to be believed, a good programming language is one for which it's possible to throw out the source code decades ago, fail to train a sufficient number of devs to read and write source files, and yet somehow, the systems running said code continue to function perfectly. What language *could* do that? Such a language doesn't exist.  To fault COBOL for failing to meet that standard is unfair. 

Better for the weaknesses to be laid bare in an exercise, however unexpected and even disconcerting the details of that failure, than in the heat of the moment. 
If Grace Hopper (and the rest of the DOD/CODASYL consortium) hadn't created this awful COBOL language in the first place, it wouldn't have been able to cause these problems. 
There will be plenty of post mortems, but as bad as it was, it could have been worse. This gives us plenty to think about for decades to come. Let's not make the same mistake twice. 

There's not analogue of "measure twice, cut once." 

California DMV project: 

Whether it's fair it not, this can happen. Beta is better than VHS but fails nevertheless. 

Innovation isn't necessary for the NJ ESC. In fact, it can even be counterproductive. [DOD using 8" floppy disks, quote about unhackable by the higher up] If it ain't broke, don't fix it. Don't revamp a nuclear guidance system just because the status quo doesn't "feel right." [over the top sarcasm guy/Dinesh D'Souza screaming snowflake]: "In my Gender Studies degree, the professors said you can't use an 8" floppy drive for a nuclear guidance system because it doesn't give off *good vibes*."  We're not aligning our chakras; we're trying to keep ourselves from getting blown off the map. 

I'm not suggesting that it shouldn't be upgraded. I'm simply pointing out the sloppy thinking that often accompanies such conversations. Some labor under the delusion that it's a foregone conclusion when in fact it's nowhere near that. It may in fact be true, I don't know. Whether true or not, it's not obviously true. Changing a nuclear guidance system must be rigorously justified, no matter whether the current implementation is "ancient" or not. 

There's . 
Where would the DOD buy replacement 8" floppies? Drives break. Whether it's an SSD circa 2020 or a RAMAC 305 (imagine two refrigerators glued together, each weighing 1000 pounds) circa 1953, they die eventually, just like everything else in life. 
If States like NY are having trouble getting ventilators, a much more common item circa 2020, it would have to be even more difficult finding 8" floppies at a reasonable price. Ebay has a 5 pack for $10, so since each olds 80KB and they're $2 each, that's 40KB/$1. That's very expensive. The DOD could 
Typically job postings list the required amount of experience. Wouldn't it be nice if we could instead hire coders based on their psychic abilities? Who cares what you've done in the past? We need to know what chaos you might inadvertantly unleash in the future. "The ideal candidate will possess 3 decades of clairvoyance, preferably 5." 
Maybe we could source the materials cheaply from China? But seriously folks...
Advantages: if he suspects a DOD employee might be rogue and later discover purchases of 8" floppies off ebay, that would be a red flag. That reminds me, I've been watching "The Americans"
Apparently when Gorbachev was vetting Russian citizens for KGB recruitment as double agents to infiltrate the U.S. government, he'd open with "Comrade, do you love mother Russia?" If that failed he'd follow up with, "Comrade, do you like to swing?" But seriously, folks...


8" floppies aren't hackable. Not entirely true, but the man makes a point. 

Wouldn't that be nice? Sure, but don't hold your breath. 

The goal isn't to eliminate chaos but to minimize it. 

Why hasn't a hacker fixed one of these systems? Because *they don't know how to*. Apparently software engineering, particularly the large scale architecture that characterizes government and corporate enterprise systems, is harder than hacking. Skeptical? Please, prove me wrong. It's too unwieldy. dog the bounty hunt but for cobol/main
dont do it twice [tbtf tweet]
they were holding the global hostge
its just hazard
"Failure to plan on your part doesn't constitute an emergency on my part." Playing devil's advocate, fixing that system wouldn't have required such a herculean effort had it been designed properly in the first place. Even more importantly, had it been properly (re)designed, documented and tested at each refactoring. Spaghetti code happens. Life's a bitch and then you die. 
There's no cure for cancer, and there's no cure for spaghetti code. Life sucks. But acknowledging that isn't the same as being defeated by it. 

volunteer: pinstriping "lets never speak of this again"
First prize is the Key to New Jersey. Second prize is two keys. But seriously folks ... I kid, I love Jersey. 

WHAT TO DO:
IBM open sources old OSs (360, etc)

Training legions of new COBOL programmers won't be a panacea. Nevertheless, it would serve an integral part of a larger effort. But even if it didn't, it would be useful anyway. 

You ever see one of those news stories about a teenager who uses his parents dial-up modem to hack into a NYSE mainframe, refactor a few thousand COBOL modules to remove spaghetti code dependencies, run regression tests to ensure that the refactored modules haven't introduced any new bugs, document like a boss, and then leave? I haven't either. Because it's never happened. And unfortunately, it most likely never will. Because software engineering is a difficult subject.



